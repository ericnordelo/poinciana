//! Defines a Cairo code emitter from a HIR.

use std::result;

use crate::{
    config::Config,
    hir::{self, visitor::Visitor, Hir},
};

/// Solidity code emitter.
///
/// This struct holds the state of the emitter. It is not
/// tied to a specific HIR.
pub struct Emitter {
    /// The indentation level of the emitted code.
    indent: usize,
}

impl Emitter {
    /// Create a new emitter with the given configuration.
    #[must_use]
    pub fn new(cfg: &Config) -> Self {
        let cfg = cfg.scaffold();
        Self { indent: cfg.indent }
    }

    /// Emit Solidity code from the given HIR.
    #[must_use]
    pub fn emit(self, hir: &hir::Hir) -> String {
        EmitterI::new(self).emit(hir)
    }

    /// Return the indentation string. i.e. the string that is used
    /// to indent the emitted code.
    fn indent(&self) -> String {
        " ".repeat(self.indent)
    }
}

/// The internal implementation of the Solidity code emitter.
///
/// This emitter generates skeleton contracts and tests functions
/// inside that contract described in the input .tree file.
struct EmitterI {
    /// The emitter state.
    emitter: Emitter,
}

impl EmitterI {
    /// Create a new emitter with the given emitter state and fn map.
    fn new(emitter: Emitter) -> Self {
        Self { emitter }
    }

    /// Emit Cairo code from the given HIR.
    ///
    /// This function is the entry point of the emitter. It is fine to unwrap
    /// here since emitting can't fail, otherwise a previous phase of the
    /// compiler is buggy.
    fn emit(&mut self, hir: &hir::Hir) -> String {
        match hir {
            Hir::Root(ref inner) => self.visit_root(inner).unwrap(),
            Hir::Target(ref inner) => self.visit_target(inner).unwrap(),
            Hir::FunctionDefinition(ref inner) => self.visit_function(inner).unwrap(),
            Hir::Comment(ref inner) => self.visit_comment(inner).unwrap(),
        }
    }

    /// Emit a fn.
    ///
    /// A fn is a helper function not anottated as test.
    fn emit_modifier(&self, modifier: &str) -> String {
        let mut emitted = String::new();
        let indentation = self.emitter.indent();
        emitted.push_str(&format!("fn {modifier}() {{\n"));
        emitted.push_str(&format!("{}// code\n", indentation));
        emitted.push_str(&format!("}}\n"));
        emitted.push('\n');

        emitted
    }

    /// Emit a test function's definition.
    fn emit_modifier_definition(&self, function: &hir::FunctionDefinition) -> String {
        let mut emitted = String::new();

        emitted.push_str("#[test]\n");
        emitted.push_str(format!("fn {}() {{\n", function.identifier).as_str());

        emitted
    }

    /// Emit a test function's fns.
    fn emit_modifiers(&self, function: &hir::FunctionDefinition) -> String {
        let mut emitted = String::new();

        let fn_indentation = self.emitter.indent();

        // Emit the fns that should be applied to this function.
        if let Some(ref modifiers) = function.modifiers {
            for modifier in modifiers {
                emitted.push_str(format!("{fn_indentation}{modifier}();\n").as_str());
            }
            emitted.push('\n');
        }

        emitted
    }
}

/// The visitor implementation for the emitter.
///
/// Note that the visitor is infallible because previous
/// passes ensure that the HIR is valid. In case an error
/// is found, it should be added to a previous pass.
impl Visitor for EmitterI {
    type CommentOutput = String;
    type Error = ();
    type FunctionDefinitionOutput = String;
    type RootOutput = String;
    type TargetOutput = String;

    fn visit_root(&mut self, root: &hir::Root) -> result::Result<Self::RootOutput, Self::Error> {
        let mut emitted = String::new();
        emitted.push_str("/// Generated by poinciana using BTT\n\n");

        for hir in &root.children {
            let result = match hir {
                Hir::Target(target) => self.visit_target(target)?,
                _ => unreachable!(),
            };

            emitted.push_str(&result);
        }

        Ok(emitted)
    }

    fn visit_target(
        &mut self,
        target: &hir::Target,
    ) -> result::Result<Self::TargetOutput, Self::Error> {
        let mut emitted = String::new();

        for hir in &target.children {
            if let Hir::FunctionDefinition(function) = hir {
                emitted.push_str(&self.visit_function(function)?);
            }
        }

        // Remove the last char, which is the extra '\n' from
        // emitting functions.
        emitted.pop();

        Ok(emitted)
    }

    fn visit_function(
        &mut self,
        function: &hir::FunctionDefinition,
    ) -> result::Result<Self::FunctionDefinitionOutput, Self::Error> {
        let mut emitted = String::new();

        if matches!(function.ty, hir::FunctionTy::Modifier) {
            emitted.push_str(&self.emit_modifier(&function.identifier));
        } else {
            let fn_definition = self.emit_modifier_definition(function);
            let fn_fns = self.emit_modifiers(function);
            emitted.push_str(&fn_definition);
            emitted.push_str(&fn_fns);

            if let Some(ref children) = function.children {
                for child in children {
                    if let Hir::Comment(comment) = child {
                        emitted.push_str(&self.visit_comment(comment)?);
                    }
                }
            }

            emitted.push_str("\n  panic!(\"NOT IMPLEMENTED\");\n");
            emitted.push_str("}\n\n");
        }

        Ok(emitted)
    }

    fn visit_comment(
        &mut self,
        comment: &hir::Comment,
    ) -> result::Result<Self::CommentOutput, Self::Error> {
        let mut emitted = String::new();
        let indentation = self.emitter.indent();
        emitted.push_str(format!("{indentation}// {}\n", comment.lexeme).as_str());

        Ok(emitted)
    }
}

#[cfg(test)]
mod tests {
    use anyhow::Result;
    use pretty_assertions::assert_eq;

    use crate::{config::Config, hir::translate, scaffold::emitter};

    fn scaffold(text: &str) -> Result<String> {
        let cfg = Config::default();
        let hir = translate(text, &cfg)?;
        Ok(emitter::Emitter::new(&cfg).emit(&hir))
    }

    #[test]
    fn one_child() -> Result<()> {
        let file_contents =
            String::from("FileTest\n└── when something bad happens\n   └── it should not revert");

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_when_something_bad_happens() {
  // it should not revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        // Test that "it should revert" actions change the test name.
        let file_contents =
            String::from("FileTest\n└── when something bad happens\n   └── it should revert");

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_panic_when_something_bad_happens() {
  // it should revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn actions_without_conditions() -> Result<()> {
        let file_contents = String::from("FileTest\n├── it should do st-ff\n└── It never reverts.");

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_should_do_st_ff() {
  // it should do st-ff

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_never_reverts() {
  // It never reverts.

  panic!("NOT IMPLEMENTED");
}
"#
        );

        let file_contents = String::from(
            "FileTest
├── it should do stuff
└── when something happens
    └── it should revert",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_should_do_stuff() {
  // it should do stuff

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_panic_when_something_happens() {
  // it should revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        let file_contents = String::from(
            "FileTest
├── it should do stuff
├── when something happens
│   └── it should revert
└── it does everything",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_should_do_stuff() {
  // it should do stuff

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_panic_when_something_happens() {
  // it should revert

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_does_everything() {
  // it does everything

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn unsanitized_input() -> Result<()> {
        let file_contents =
            String::from("Fi-eTest\n└── when something bad happens\n   └── it should not revert");

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_when_something_bad_happens() {
  // it should not revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn indentation() -> Result<()> {
        let file_contents =
            String::from("FileTest\n└── when something bad happens\n   └── it should not revert");

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_when_something_bad_happens() {
  // it should not revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn two_children() -> Result<()> {
        let file_contents = String::from(
            r"TwoChildren_test
├── when stuff called
│  └── it should revert
└── when not stuff called
   └── it should revert",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_panic_when_stuff_called() {
  // it should revert

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_panic_when_not_stuff_called() {
  // it should revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn action_with_sibling_condition() -> Result<()> {
        let file_contents = String::from(
            r"
Foo_test
└── when stuff called
    ├── It should do stuff.
    ├── when a called
    │   └── it should revert
    ├── It should do more.
    └── when b called
        └── it should not revert",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

fn when_stuff_called() {
  // code
}

#[test]
fn test_when_stuff_called() {
  when_stuff_called();

  // It should do stuff.
  // It should do more.

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_panic_when_a_called() {
  when_stuff_called();

  // it should revert

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_when_b_called() {
  when_stuff_called();

  // it should not revert

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn action_recollection() -> Result<()> {
        let file_contents = String::from(
            r"Actions_test
└── when stuff called
   ├── it should do stuff
   ├── it should be cool
   └── it might break
",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_when_stuff_called() {
  // it should do stuff
  // it should be cool
  // it might break

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn first_action_revert_emits_revert_when() -> Result<()> {
        let file_contents = String::from(
            r"Actions_test
└── when stuff called
   ├── it should revert
   ├── it should be cool
   └── it might break
",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_panic_when_stuff_called() {
  // it should revert
  // it should be cool
  // it might break

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn weird_it_should_revert_emits_revert_when() -> Result<()> {
        let file_contents = String::from(
            r"Actions_test
└── when stuff called
   └── IT sHould RevERT.
",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_panic_when_stuff_called() {
  // IT sHould RevERT.

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn non_firt_child_it_should_revert_doesnt_emit_revert_when() -> Result<()> {
        let file_contents = String::from(
            r"Actions_test
└── when stuff called
   ├── it should be cool
   ├── it should revert
   └── it might break
",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_when_stuff_called() {
  // it should be cool
  // it should revert
  // it might break

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn action_descriptions() -> Result<()> {
        let file_contents = String::from(
            r"Descriptions_test
└── when something bad happens
   └── it should try to revert
      ├── some stuff happened
      │  └── and that stuff
      └── was very _bad_",
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_when_something_bad_happens() {
  // it should try to revert
  //    some stuff happened
  //       and that stuff
  //    was very _bad_

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }

    #[test]
    fn deep_tree() -> Result<()> {
        let file_contents = String::from(
            r#"DeepTest
├── when stuff called
│  └── it should revert
└── when not stuff called
   ├── when the deposit amount is zero
   │  └── it should revert
   └── when the deposit amount is not zero
      ├── when the number count is zero
      │  └── it should revert
      ├── when the asset is not a contract
      │  └── it should revert
      └── given the asset is a contract
          ├── when the asset misses the ERC-20 return value
          │  ├── it should create the child
          │  ├── it should perform the ERC-20 transfers
          │  └── it should emit a {MultipleChildren} event
          └── when the asset does not miss the ERC-20 return value
              ├── it should create the child
              └── it should emit a {MultipleChildren} event
                 ├── - Because the deposit should not be 0.
                 ├── - The number count is > 0.
                 └── - Events should be emitted."#,
        );

        assert_eq!(
            &scaffold(&file_contents)?,
            r#"/// Generated by poinciana using BTT

#[test]
fn test_panic_when_stuff_called() {
  // it should revert

  panic!("NOT IMPLEMENTED");
}

fn when_not_stuff_called() {
  // code
}

#[test]
fn test_panic_when_the_deposit_amount_is_zero() {
  when_not_stuff_called();

  // it should revert

  panic!("NOT IMPLEMENTED");
}

fn when_the_deposit_amount_is_not_zero() {
  // code
}

#[test]
fn test_panic_when_the_number_count_is_zero() {
  when_not_stuff_called();
  when_the_deposit_amount_is_not_zero();

  // it should revert

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_panic_when_the_asset_is_not_a_contract() {
  when_not_stuff_called();
  when_the_deposit_amount_is_not_zero();

  // it should revert

  panic!("NOT IMPLEMENTED");
}

fn given_the_asset_is_a_contract() {
  // code
}

#[test]
fn test_when_the_asset_misses_the_erc_20_return_value() {
  when_not_stuff_called();
  when_the_deposit_amount_is_not_zero();
  given_the_asset_is_a_contract();

  // it should create the child
  // it should perform the ERC-20 transfers
  // it should emit a {MultipleChildren} event

  panic!("NOT IMPLEMENTED");
}

#[test]
fn test_when_the_asset_does_not_miss_the_erc_20_return_value() {
  when_not_stuff_called();
  when_the_deposit_amount_is_not_zero();
  given_the_asset_is_a_contract();

  // it should create the child
  // it should emit a {MultipleChildren} event
  //    - Because the deposit should not be 0.
  //    - The number count is > 0.
  //    - Events should be emitted.

  panic!("NOT IMPLEMENTED");
}
"#
        );

        Ok(())
    }
}
