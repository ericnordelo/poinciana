# poinciana

[![coverage](https://codecov.io/github/ericnordelo/poinciana/coverage.svg?branch=main)](https://codecov.io/gh/ericnordelo/poinciana)

A Cairo test generator based on the
[Branching Tree Technique](https://twitter.com/PaulRBerg/status/1682346315806539776)
and [bulloak](https://github.com/alexfertel/bulloak).

- [Installation](#installation)
  - [VSCode](#vscode)
- [Usage](#usage)
  - [`poinciana scaffold`](#scaffold-cairo-files)
- [Trees](#trees)
  - [Terminology](#terminology)
  - [Spec](#spec)
- [License](#license)

## Installation

```bash
cargo install poinciana
```

### VSCode

The following VSCode extensions are not essential but they are recommended for a
better user experience:

- [Ascii Tree Generator](https://marketplace.visualstudio.com/items?itemName=aprilandjan.ascii-tree-generator):
  convenient way to generate ASCII trees

## Usage

`poinciana` implements two commands:

- `poinciana scaffold`
- `poinciana check` (in the roadmap)

### Scaffold Cairo Files

Say you have a `foo.tree` file with the following contents:

```tree
FooTest
└── When stuff is called // Comments are supported.
    └── When a condition is met
        └── It should revert.
            └── Because we shouldn't allow it.
```

You can use `poinciana scaffold` to generate a Cairo contract containing
modifiers and tests that match the spec described in `foo.tree`. The following
will be printed to `stdout`:

```solidity
/// Generated by poinciana using BTT

fn when_stuff_is_called() {
  // code
}

#[test]
fn test_panic_when_a_condition_is_met() {
    when_stuff_is_called();

    // It should revert.
    //     Because we shouldn't allow it.

    panic!("NOT IMPLEMENTED");
}
```

## Trees

`bulloak scaffold` scaffolds Solidity test files based on `.tree` specifications
that follow the
[Branching Tree Technique](https://twitter.com/PaulRBerg/status/1682346315806539776).

Currently, there is on-going
[discussion](https://github.com/alexfertel/bulloak/discussions) on how to handle
different edge-cases to better empower the Solidity community. This section is a
description of the current implementation of the compiler.

### Terminology

- _Condition_: `when/given` branches of a tree.
- _Action_: `it` branches of a tree.
- _Action Description_: Children of an action.

### Spec

Each `tree` file should describe at least one function under test. Trees follow
these rules:

- The first line is the root tree identifier, composed of the contract and
  function names which should be delimited by a double colon.
- `bulloak` expects you to use `├` and `└` characters to denote branches.
- If a branch starts with either `when` or `given`, it is a condition.
  - `when` and `given` are interchangeable.
- If a branch starts with `it`, it is an action.
  - Any child branch an action has is called an action description.
- Keywords are case-insensitive: `it` is the same as `It` and `IT`.
- Anything starting with a `//` is a comment and will be stripped from the
  output.
- Multiple trees can be defined in the same file to describe different functions
  by following the same rules, separating them with two newlines.

Take the following Solidity function:

```solidity
function hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
    return a < b ? hash(a, b) : hash(b, a);
}
```

A reasonable spec for the above function would be:

```tree
HashPairTest
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the result of `keccak256(abi.encodePacked(a,b))`.
└── When first arg is bigger than second arg
    └── It should match the result of `keccak256(abi.encodePacked(b,a))`.
```

There is a top-level action that will generate a test to check the function
invariant that it should never revert.

Then, we have the two possible preconditions: `a < b` and `a >= b`. Both
branches end in an action that will make `bulloak scaffold` generate the
respective test.

Note the following things:

- Actions are written with ending dots but conditions are not. This is because
  actions support any character, but conditions don't. Since conditions are
  transformed into modifiers, they have to be valid Solidity identifiers.
- You can have top-level actions without conditions. Currently, `bulloak` also
  supports actions with sibling conditions, but this might get removed in a
  future version per this
  [discussion](https://github.com/alexfertel/bulloak/issues/22).
- The root of the tree will be emitted as the name of the test contract.

Suppose you have additional Solidity functions that you want to test in the same
test contract, say `Utils` within `utils.t.sol`:

```solidity
function min(uint256 a, uint256 b) private pure returns (uint256) {
    return a < b ? a : b;
}

function max(uint256 a, uint256 b) private pure returns (uint256) {
    return a > b ? a : b;
}
```

The full spec for all the above functions would be:

```tree
Utils::hashPair
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the result of `keccak256(abi.encodePacked(a,b))`.
└── When first arg is bigger than second arg
    └── It should match the result of `keccak256(abi.encodePacked(b,a))`.


Utils::min
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the value of `a`.
└── When first arg is bigger than second arg
    └── It should match the value of `b`.


Utils::max
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the value of `b`.
└── When first arg is bigger than second arg
    └── It should match the value of `a`.
```

Note the following things:

- Contract identifiers must be present in all roots.
- Contract identifiers that are missing from subsequent trees, or otherwise
  mismatched from the first tree root identifier, will cause `bulloak` to error.
  This violation is not currently fixable with `bulloak check --fix` so will
  need to be manually corrected.
- Duplicate conditions between separate trees will be deduplicated when
  transformed into Solidity modifiers.
- The function part of the root identifier for each tree will be emitted as part
  of the name of the Solidity test (e.g. `test_MinShouldNeverRevert`).
